/************************************************************************************************************************************
Copyright 2017 Autodesk, Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. 
You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, 
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
See the License for the specific language governing permissions and limitations under the License.
************************************************************************************************************************************/

#include "common/ParamsCommon.h"
#include "common/Tools.h"
#include "loader/ICE.h"
#include "loader/Instances.h"
#include "loader/Lights.h"
#include "loader/Loader.h"
#include "loader/Properties.h"
#include "loader/Procedurals.h"
#include "loader/Volume.h"
#include "renderer/Renderer.h"


// Load all the pointcloud objects
//
// @param in_frame               The frame
// @param in_selectedObjs        The selected objs to render (if in_selectionOnly==true)
// @param in_selectionOnly       True is only in_selectedObjs must be rendered
// @return CStatus:OK if all went well, else the error CStatus
//
CStatus LoadPointClouds(double in_frame, CRefArray &in_selectedObjs, bool in_selectionOnly)
{
   if (GetRenderInstance()->InterruptRenderSignal())
      return CStatus::Abort;

   CStatus status(CStatus::OK);

   if (GetRenderOptions()->m_ignore_pointclouds)
      return CStatus::OK;

   // Get all the ICE pointclouds
   CStringArray families;
   families.Add(siPointCloudFamily);
   CRefArray pointClouds = Application().GetActiveSceneRoot().FindChildren(L"" ,L"", families, true);

   vector <AtNode*> postLoadedNodesToHide;
   for (LONG i= 0; i < pointClouds.GetCount(); i++)
   {
      // check if this pointcloud is selected
      if (in_selectionOnly && !ArrayContainsCRef(in_selectedObjs, pointClouds[i]))
         continue;
      X3DObject pc(pointClouds[i]);
      vector <AtNode*> nodesToHide;
      status = LoadSinglePointCloud(pc, in_frame, in_selectedObjs, in_selectionOnly, nodesToHide);
      if (status != CStatus::OK)
         break;
         
      // collect the nodes to be hidden later (see below)
      for (vector <AtNode*>::iterator it=nodesToHide.begin(); it!=nodesToHide.end(); it++)
         postLoadedNodesToHide.push_back(*it);
      nodesToHide.clear();
   }

   // Hide the master nodes generated by time-shifted ICE instances (#1369).
   // We must do it here, and not inside LoadSinglePointCloud because of #1470.
   // In fact, a postloaded (time-instanced) node could be created by one pc, and 
   // found exported, and so looked up, by another pc. 
   // So, we must preserve its visibility until the very end the pcs loop.
   for (vector <AtNode*>::iterator it=postLoadedNodesToHide.begin(); it!=postLoadedNodesToHide.end(); it++)
      CNodeSetter::SetByte(*it, "visibility", 0, true);
   postLoadedNodesToHide.clear();

   return status;
}


// Load a pointcloud object
//
// @param in_xsiObj              The Softimage pc
// @param in_frame               The frame
// @param in_selectedObjs        The selected objs to render (if in_selectionOnly==true)
// @param in_selectionOnly       True is only in_selectedObjs must be rendered
// @param out_postLoadedNodes    Returned vector of nodes that must be later hidden
//
// @return CStatus:OK if all went well, else the error CStatus
//
CStatus LoadSinglePointCloud(const X3DObject &in_xsiObj, double in_frame, 
                             CRefArray &in_selectedObjs, bool in_selectionOnly, vector <AtNode*> &out_postLoadedNodesToHide)
{
   if (GetRenderInstance()->InterruptRenderSignal())
      return CStatus::Abort;

   LockSceneData lock;
   if (lock.m_status != CStatus::OK)
      return CStatus::Abort;

   int objectID = CObjectUtilities().GetId(in_xsiObj);

   // 1199: since a pointcloud p1 could be postloaded, because instanced by another pointcloud p0 created
   // before p1, let's be sure that p1 was not exported yet. If so, just quit.
   AtNode* masterNode = NULL;
   vector <AtNode*> *masterNodes;
   masterNode = GetRenderInstance()->NodeMap().GetExportedNode(in_xsiObj, in_frame);
   if (masterNode)
      return CStatus::OK;
   if (GetRenderInstance()->GroupMap().GetGroupNodes(&masterNodes, in_xsiObj, in_frame))
      return CStatus::OK;

   // Moving the hidden test up, before everything else (#1189)
   CRefArray iceProperties = in_xsiObj.GetProperties();
   // If PointCloud is invisible we will not do anything
   Property xsiVizProperty = iceProperties.GetItem(L"Visibility");
   if (!ParAcc_GetValue(xsiVizProperty, L"rendvis", in_frame))
      return CStatus::OK;

   // is this a procedural ? 
   if (iceProperties.GetItem(L"arnold_procedural").IsValid())
      return LoadSingleProcedural(in_xsiObj, in_frame, in_selectedObjs, in_selectionOnly); //bye bye
   // is this a volume ?
   if (iceProperties.GetItem(L"arnold_volume").IsValid())
      return LoadSingleVolume(in_xsiObj, in_frame, in_selectedObjs, in_selectionOnly);
   // has step_size ?
   if (GetStepSize(in_xsiObj, in_frame) > 0.0f)
      return LoadVolumePointCloud(in_xsiObj, in_frame);

   float frameRate = (float)CTimeUtilities().GetFps();
   float secondsPerFrame = frameRate > 1.0 ? 1.0f / frameRate : 1.0f;
   // preliminar step: store, for each shape instance node, if it's in object only or in hierarhy mode (#1728)
   ShapeHierarchyModeMap shapeHierarchyMap;
   CIceUtilities().SearchAllTreesForShapeNodes(in_xsiObj, shapeHierarchyMap);

   Geometry xsiGeo = CObjectUtilities().GetGeometryAtFrame(in_xsiObj, in_frame);

   // initialize the main attributes set
   CIceAttributesSet iceAttributes(in_xsiObj, xsiGeo);
   // collect all the required attributes, the second arg is void since it's used only for polymeshes
   iceAttributes.CollectRequiredAttributes(in_frame, CRefArray(), false, false);

   CString xsiObjName = in_xsiObj.GetFullName();

   CDoubleArray keyTransformAtTimeZero, keyDeformAtTimeZero, keyTransformAtFrame, keyDeformAtFrame;
   // get the mb times at time 0 (#809)
   CSceneUtilities::GetMotionBlurData(in_xsiObj.GetRef(), keyTransformAtTimeZero, keyDeformAtTimeZero, 0, true);
   // #532: get the actual time for the mb steps, not centered at 0 as above.
   CSceneUtilities::GetMotionBlurData(in_xsiObj.GetRef(), keyTransformAtFrame, keyDeformAtFrame, in_frame, true);
   LONG nbTransfKeys = keyTransformAtTimeZero.GetCount();
   LONG nbDefKeys    = keyDeformAtTimeZero.GetCount();

   // find the arnold settings
   CustomProperty arnoldParameters, userOptionsProperty, matteProperty;
   iceProperties.Find(L"arnold_parameters", arnoldParameters);
   iceProperties.Find(L"arnold_user_options", userOptionsProperty); /// #680
   if (!GetRenderOptions()->m_ignore_matte)
      iceProperties.Find(L"arnold_matte", matteProperty);

   // Parsing Material (this shaderNode will be applied to all shapes/instances generated)
   Material material(in_xsiObj.GetMaterial());

   AtNode* shaderNode = LoadMaterial(material, LOAD_MATERIAL_SURFACE, in_frame, in_xsiObj.GetRef());

   // Visibility & Sidedness (will be applied to all shapes generated by ICE)
   // check if the arnold viz exist (#1031). If so, we will use it.
   // if not, we'll use for instances the masters' visibility.
   Property prop;
   iceProperties.Find(L"arnold_visibility", prop);
   bool arnoldVisibilityOnPointCloud = prop.IsValid();

   uint8_t pointCloudVisibility = GetVisibility(iceProperties, in_frame);

   uint8_t pointCloudSidedness;
   bool arnoldSidednessOnPointCloud = GetSidedness(iceProperties, in_frame, pointCloudSidedness);
   // also get the visibility WITHOUT looking at the Instance Master Hidden flag
   // unsigned int pointCloudVisibilityUnhidden = GetVisibility(iceProperties, in_frame, false);

   // check the pointPosition attribute, if is invalid or empty skip this cloud
   ICEAttribute pointPositionAttribute = xsiGeo.GetICEAttributeFromName(L"PointPosition");
   LONG pointCount = pointPositionAttribute.GetElementCount();
   
   if (!pointPositionAttribute.IsDefined() || !pointPositionAttribute.IsValid() || pointCount == 0)
      return CStatus::OK;

   // check the number of point counts at different frame times
   Geometry mbXsiGeo;
   bool doExactTransformMb(false), doExactDeformMb(false);

   if (GetRenderOptions()->m_exact_ice_mb && (nbTransfKeys > 1 || nbDefKeys > 1))
   {
      CIceUtilities().IsPointCountTheSameAtAllMbSteps(in_xsiObj, pointCount, keyTransformAtFrame, keyDeformAtFrame, in_frame, doExactTransformMb, doExactDeformMb);
      // awful, but if we don't re-evaluate the active primitive at the curremt time, 
      // the last geo evaluated by IsPointCountTheSameAtAllMbSteps "replaces" the main geometry (xsiGeo). No idea why
      mbXsiGeo = CObjectUtilities().GetGeometryAtFrame(in_xsiObj, in_frame);
   }

   // prepare iceAttributes to host the required attributes
   iceAttributes.GetRequiredAttributesSet();
   // add all necessary provided attributes to the required map
   iceAttributes.GetProvidedAttributesSet();
   // now let's query all ice attributes that need to be pushed
   iceAttributes.BuildAttributesMaps(true, true);
   // flag telling if there are required attributes to be pushed
   bool doAttributes = iceAttributes.m_requiredAttributesMap.size() > 0;
   // get direct access to the attributes into iceAttributes
   iceAttributes.ConnectAttributeHandlers();

   // the main class, hosting all the nodes to be created
   CIceObjects iceObjects;
   
   CShape shape;
   siICEShapeType shapeType;
   CICEAttributeDataArrayVector3f  strandPos, strandVel;
   CICEAttributeDataArrayFloat     strandSize;
   CICEAttributeDataArrayRotationf strandOrientation;
   CICEAttributeDataArrayVector3f  dummyDav;

   // first of all: let's count the number of shapes per each type, since we will
   // store them all together. I prefer to do so, and so resize the vectors just once,
   // instead of a long series of push_backs
   for (LONG pointOffset=0; pointOffset < pointCount; pointOffset+=ICE_CHUNK_SIZE)
   {
      LONG nbPoints = pointCount - pointOffset < ICE_CHUNK_SIZE ? pointCount - pointOffset : ICE_CHUNK_SIZE;
      iceAttributes.UpdateChunk(pointOffset, nbPoints); //update all the main attributes

      for (LONG pointIndex = 0; pointIndex < nbPoints; pointIndex++)
      {
         // #1417
         if (iceAttributes.GetSize(pointIndex, 1.0f) < 0.0001f) 
            continue;

         shape = iceAttributes.GetShape(pointIndex);
         shapeType = shape.GetType();

         // Is there a strand for this point? also, skip strands with a single point (#1215)
         if (iceAttributes.GetStrandPosition(pointIndex, strandPos) && (strandPos.GetCount() > 1))
         {
            if (shapeType == siICEShapeInstance || shapeType == siICEShapeReference) // strand instance
               iceObjects.m_nbStrandInstances++;
            else 
               iceObjects.m_nbStrands++; // regular strand, rendered as curve

            continue; // skip to the next point
         }
         // non strand
         switch (shapeType)
         {
            case siICEShapeSphere:
               iceObjects.m_pointsSphereNbPoints++;
               break;
            case siICEShapePoint: // points shapes are exported as Arnold points with mode==disks
               iceObjects.m_pointsDiskNbPoints++;
               break;
            case siICEShapeDisc:
               iceObjects.m_nbDiscs++;
               break;
            case siICEShapeRectangle:
               iceObjects.m_nbRectangles++;
               break;
            case siICEShapeBox:
               iceObjects.m_nbBoxes++;
               break;
            case siICEShapeCylinder:
               iceObjects.m_nbCylinders++;
               break;
            case siICEShapeCone:
               iceObjects.m_nbCones++;
               break;
            case siICEShapeInstance:
            case siICEShapeReference:
               iceObjects.m_nbInstances++;
               break;
            default:
               break;
         }
      }
   }

   // iceObjects.Log();

   if (iceObjects.m_pointsSphereNbPoints > 0)
   {
      // we have at least a sphere object, that is exported as a points node with mode = sphere
      iceObjects.m_pointsSphere.resize(1); // alloc the object. resize(1) may look weird, but I prefer to be consistent with the rest
      CString name = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Sphere", false);
      iceObjects.m_pointsSphere[0].CreateNode(objectID, name.GetAsciiString(), nbTransfKeys);
      iceObjects.m_pointsSphere[0].Resize(iceObjects.m_pointsSphereNbPoints, nbTransfKeys);
   }
   if (iceObjects.m_pointsDiskNbPoints > 0) // same as above, mode will be disk
   {
      iceObjects.m_pointsDisk.resize(1);
      CString name = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Disk", false);
      iceObjects.m_pointsDisk[0].CreateNode(objectID, name.GetAsciiString(), nbTransfKeys);
      iceObjects.m_pointsDisk[0].Resize(iceObjects.m_pointsDiskNbPoints, nbTransfKeys);
   }
   if (iceObjects.m_nbRectangles > 0) // node will be polymesh
   {
      iceObjects.m_rectangles.resize(1);
      CString name = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Rectangles", false);
      iceObjects.m_rectangles[0].CreateNode(objectID, name.GetAsciiString(), nbTransfKeys);
      iceObjects.m_rectangles[0].Resize(iceObjects.m_nbRectangles, nbTransfKeys, doExactTransformMb);
   }
   if (iceObjects.m_nbDiscs > 0) // Softimage discs, exported as Arnold disc nodes
   {
      iceObjects.m_discs.resize(iceObjects.m_nbDiscs); // one node per point
      CString baseName = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Disc", false) + L".";
      char* name = (char*)alloca(baseName.Length() + 1 + 20 + 1);
      char* name_index_start = name + baseName.Length() + 1;
      sprintf(name, "%s:", baseName.GetAsciiString());

      for (int i = 0; i < iceObjects.m_nbDiscs; i++)
      {
         sprintf(name_index_start, "%d", i);
         iceObjects.m_discs[i].CreateNode(objectID, name, nbTransfKeys);
      }
   }
   if (iceObjects.m_nbBoxes > 0)
   {
      iceObjects.m_boxes.resize(iceObjects.m_nbBoxes);
      CString baseName = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Box", false) + L".";
      char* name = (char*)alloca(baseName.Length() + 1 + 20 + 1);
      char* name_index_start = name + baseName.Length() + 1;
      sprintf(name, "%s:", baseName.GetAsciiString());

      for (int i = 0; i < iceObjects.m_nbBoxes; i++)
      {
         sprintf(name_index_start, "%d", i);
         iceObjects.m_boxes[i].CreateNode(objectID, name, nbTransfKeys);
      }
   }
   if (iceObjects.m_nbCylinders > 0)
   {
      iceObjects.m_cylinders.resize(iceObjects.m_nbCylinders);
      CString baseName = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Cylinder", false) + L".";
      char* name = (char*)alloca(baseName.Length() + 1 + 20 + 1);
      char* name_index_start = name + baseName.Length() + 1;
      sprintf(name, "%s:", baseName.GetAsciiString());

      for (int i = 0; i < iceObjects.m_nbCylinders; i++)
      {
         sprintf(name_index_start, "%d", i);
         iceObjects.m_cylinders[i].CreateNode(objectID, name, nbTransfKeys);
      }
   }
   if (iceObjects.m_nbCones > 0)
   {
      iceObjects.m_cones.resize(iceObjects.m_nbCones);
      CString baseName = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Cone", false) + L".";
      char* name = (char*)alloca(baseName.Length() + 1 + 20 + 1);
      char* name_index_start = name + baseName.Length() + 1;
      sprintf(name, "%s:", baseName.GetAsciiString());

      for (int i = 0; i < iceObjects.m_nbCones; i++)
      {
         sprintf(name_index_start, "%d", i);
         iceObjects.m_cones[i].CreateNode(objectID, name, nbTransfKeys);
      }
   }
   if (iceObjects.m_nbStrands > 0) // we have at least one strand, create the strands[0] object
   {
      iceObjects.m_strands.resize(1); // also here, we use the resize(1) way
      CString name = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Strands", false);
      iceObjects.m_strands[0].CreateNode(objectID, name.GetAsciiString(), nbTransfKeys);
      iceObjects.m_strands[0].Init(iceObjects.m_nbStrands); // initialize everytihng, ready to host all the strands
   }
   if (iceObjects.m_nbInstances > 0)
   {
      iceObjects.m_instances.resize(iceObjects.m_nbInstances); // we'll have one instance per point
      CString baseName = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Instance", false) + L".";
      char* name = (char*)alloca(baseName.Length() + 1 + 20 + 1);
      char* name_index_start = name + baseName.Length() + 1;
      sprintf(name, "%s:", baseName.GetAsciiString());

      for (int i = 0; i < iceObjects.m_nbInstances; i++)
      {
         sprintf(name_index_start, "%d", i);
         iceObjects.m_instances[i].CreateNode(objectID, name, nbTransfKeys);
      }
   }
   if (iceObjects.m_nbStrandInstances > 0)
   {
      iceObjects.m_strandInstances.resize(iceObjects.m_nbStrandInstances); // we'll have one instance per strand
      CString baseName = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"InstancedStrands", false) + L".";
      char* name = (char*)alloca(baseName.Length() + 1 + 20 + 1);
      char* name_index_start = name + baseName.Length() + 1;
      sprintf(name, "%s:", baseName.GetAsciiString());

      for (int i = 0; i < iceObjects.m_nbStrandInstances; i++)
      {
         sprintf(name_index_start, "%d", i);
         // this won't be a ginstance, though. It's a polymesh (or a set of pm)
         iceObjects.m_strandInstances[i].CreateNode(objectID, name, nbTransfKeys);
      }
   }

   // counters for each node type
   int pointsSphereIndex(0), pointsDiskIndex(0), rectanglesIndex(0), discIndex(0), boxIndex(0),
       cylinderIndex(0), coneIndex(0), strandIndex(0), instanceIndex(0), strandInstanceIndex(0);

   CVector3f  pos, vel, scale;
   CRotation  ori, angVel;
   CRotationf orientationf;
   float      size;
   double     shapeFrame(in_frame);
   int        index;
   X3DObject  masterShapeObj;

   // the attributes at the mb frame time
   vector <CVector3f> mbPos, mbScale;
   vector <float>     mbSize;
   vector <CRotation> mbOri;
   // exact strand mb #1002
   // vector <CICEAttributeDataArrayVector3f>  mbStrandPos;
   // For exact mb on strands, we have to collect the points for each strand at each mb time.
   // We can't use a vector of CICEAttributeDataArrayVector3f as we did before, because they are a reference
   // to the current geo arrays, and their evaluation does not work at times other than the current one.
   // So, we use a double vector. Big memory eater, but just for exact mb.
   vector < vector < CVector3f > >  mbStrandPos;

   // #1369: vector for storing all the postloaded nodes that will be hidden because loaded for time-shifted instance shapes

   // loop to fill the iceAttributes class with all the needed data
   for (LONG pointOffset=0; pointOffset < pointCount; pointOffset+=ICE_CHUNK_SIZE)
   {
      LONG nbPoints = pointCount - pointOffset < ICE_CHUNK_SIZE ? pointCount - pointOffset : ICE_CHUNK_SIZE;
      // evaluate at the main frame time
      iceAttributes.UpdateChunk(pointOffset, nbPoints);

      if (doExactTransformMb)
      {
         // we use a single raw vector for each of the attributes to be stored at the mb keys.
         // We could have used a double vector (per mb time and per point), but resizing them would
         // be quite expensive. Also, this is easier to pass as argument for the ComputeMotionBlur methods.
         // Since when we call ComputeMotionBlur we must pass the mb pos, scale, etc for the current point index,
         // the vectors will be filled per point. So, if for example there are 3 keys,
         // mbPos[0] = pos of point 0 at time 0
         // mbPos[1] = pos of point 0 at time 1
         // mbPos[2] = pos of point 0 at time 2
         // mbPos[3] = pos of point 1 at time 0
         // mbPos[4] = pos of point 1 at time 1
         // etc.
         mbPos.resize  (nbTransfKeys*nbPoints);
         mbScale.resize(nbTransfKeys*nbPoints);
         mbSize.resize (nbTransfKeys*nbPoints);
         mbOri.resize  (nbTransfKeys*nbPoints);
         // evaluate the subframes
         for (int iKey = 0; iKey < nbTransfKeys; iKey++)
         {
            CIceAttributesSet  transformMbIceAttributes;
            double mbFrameTime = keyTransformAtFrame[iKey];

            mbXsiGeo = CObjectUtilities().GetGeometryAtFrame(in_xsiObj, mbFrameTime);

            transformMbIceAttributes.Init(in_xsiObj, mbXsiGeo);
            // below: true == only the attributes needed for mb (position etc), no velocity etc
            transformMbIceAttributes.GetProvidedAttributesSet(true); 
            transformMbIceAttributes.BuildAttributesMaps();
            transformMbIceAttributes.ConnectAttributeHandlers();
            transformMbIceAttributes.UpdateChunk(pointOffset, nbPoints);
            // fill the mb vectors
            for (LONG pointIndex = 0; pointIndex < nbPoints; pointIndex++)
            {
               mbPos  [pointIndex*nbTransfKeys + iKey] = transformMbIceAttributes.GetPointPosition(pointIndex);
               mbScale[pointIndex*nbTransfKeys + iKey] = transformMbIceAttributes.GetScale(pointIndex);
               mbSize [pointIndex*nbTransfKeys + iKey] = transformMbIceAttributes.GetSize(pointIndex, 1.0f);
               mbOri  [pointIndex*nbTransfKeys + iKey] = transformMbIceAttributes.GetOrientation(pointIndex);
            }
         }
      }
      if (doExactDeformMb)
      {
         // same as what we did above for points, except each element of mbStrandPos is a vector of points
         mbStrandPos.resize(nbDefKeys*nbPoints);
         // evaluate the subframes
         for (int iKey = 0; iKey < nbDefKeys; iKey++)
         {
            CIceAttributesSet  deformMbIceAttributes;
            double mbFrameTime = keyDeformAtFrame[iKey];

            mbXsiGeo = CObjectUtilities().GetGeometryAtFrame(in_xsiObj, mbFrameTime);

            deformMbIceAttributes.Init(in_xsiObj, mbXsiGeo);
            // below: true == only the attributes needed for mb (position etc), no velocity etc
            deformMbIceAttributes.GetProvidedAttributesSet(true); 
            deformMbIceAttributes.BuildAttributesMaps();
            deformMbIceAttributes.ConnectAttributeHandlers();
            deformMbIceAttributes.UpdateChunk(pointOffset, nbPoints);

            for (LONG pointIndex = 0; pointIndex < nbPoints; pointIndex++)
               deformMbIceAttributes.GetStrandPosition(pointIndex, dummyDav, mbStrandPos[pointIndex*nbDefKeys + iKey]);
         }
      }

      for (LONG pointIndex = 0; pointIndex < nbPoints; pointIndex++)
      {
         size = iceAttributes.GetSize(pointIndex, 1.0f);
         if (size < 0.0001f) 
            continue;

         shape     = iceAttributes.GetShape(pointIndex);
         shapeType = shape.GetType();
         pos       = iceAttributes.GetPointPosition(pointIndex);
         if (nbTransfKeys > 1)
            vel = iceAttributes.GetPointVelocity(pointIndex);

         shapeFrame = iceAttributes.HasShapeTime() ? 
                      (double)iceAttributes.GetShapeTime(pointIndex, 0.0f) * CTime().GetFrameRate() : in_frame;

         // check if this point originates a strand.
         // All the data (points, radii, vel), are stored into a the CStrand class, shaders with the
         // hair instancing part. We waste (duplicate) memory in favour of a cleaner design

         bool isStrandInstance = false;
         if (iceAttributes.GetStrandPosition(pointIndex, strandPos) && (strandPos.GetCount() > 1))
         {
            if (shapeType == siICEShapeInstance || shapeType == siICEShapeReference) // bending objects
               isStrandInstance = true; // jumping down to the shape type switcher 
            else // regular strand rendered as curve
            {
               // is there a StrandSize attribute?
               bool strandSizeOk = iceAttributes.GetStrandSize(pointIndex, strandSize);
               // is there a StrandVelocity attribute?
               bool strandVelOk = iceAttributes.GetStrandVelocity(pointIndex, strandVel);
               // strand orientation ? #1249
               bool strandOrientationOk = iceAttributes.GetStrandOrientation(pointIndex, strandOrientation);

               int nbStrandPoints = (int)strandPos.GetCount();
               int nbStrandVel = nbTransfKeys > 1 ? nbStrandPoints : 0;
               int nbStrandOrientation = (int)strandPos.GetCount();
               // alloc the strand structure. This strand has nbStrandPoints points, nbStrandPoints radii, 
               // and nbStrandVel velocities (that is 0 if mb is off)
               CStrand *strand = &iceObjects.m_strands[0].m_strands[strandIndex];
               strand->Init(nbStrandPoints, nbStrandPoints, nbStrandVel, nbStrandOrientation, doExactDeformMb, nbDefKeys);

               for (int i=0; i<nbStrandPoints; i++)
               {
                  CVector3f strandP = strandPos[i];
                  // set the i-th strand's point position
                  strand->SetPoint(strandP, i);
                  if (strandSizeOk)
                  {
                     // set the radius equal to the strand size at i
                     index = strandSize.GetCount() > 1 ? i : 0;
                     float strandS = strandSize[index];
                     strand->SetRadius(strandS, i);
                  }
                  else // no strand size. Use the point's size, so the strand has uniform thickness
                     strand->SetRadius(size, i);

                  if (nbDefKeys > 1) // set strand points' velocity
                  {
                     if (doExactDeformMb)
                     {
                        for (int iKey = 0; iKey < nbDefKeys; iKey++)
                        {
                           // We se the mkKey-th position for the i-th strand. Note that in case of growing strands, the
                           // number of strand points may differ at each mb deform time. SetMbPoint is protected against
                           // out-of-range vector indeces, but of course mb will be wrong
                           if (mbStrandPos[pointIndex * nbDefKeys + iKey].size() > 0)
                              strand->SetMbPoint(mbStrandPos[pointIndex * nbDefKeys + iKey][i], i, iKey);
                        }
                     }
                     else
                     {
                        if (strandVelOk)
                        {
                           // set the velocities equal to the strand sizes
                           index = strandVel.GetCount() > 1 ? i : 0;
                           CVector3f strandV = strandVel[index];
                           strand->SetVelocity(strandV, i);
                        }
                        else // no strand vel. Use the point's velocity, so the strand has uniform velocity
                           strand->SetVelocity(vel, i);
                     }
                  }

                  // #1249
                  // set the i-th point orientation
                  if (strandOrientationOk)
                  {
                     // set the orientation equal to the strand size at i
                     index = strandOrientation.GetCount() > 1 ? i : 0;
                     CRotationf strandR = strandOrientation[index];
                     strand->SetOrientation(strandR, i);
                  }
                  else
                     strand->SetOrientation(orientationf, i);
               }

               strandIndex++;
               continue; // go to the next point
            } // finished filling the data for the strand

         }

         scale = iceAttributes.GetScale(pointIndex);
         // get the common attributes for the single-point nodes (derived from CIceObjectBaseShape)
         if (shapeType == siICEShapeDisc || shapeType == siICEShapeBox || 
             shapeType == siICEShapeCylinder || shapeType == siICEShapeCone || shapeType == siICEShapeInstance ||
             shapeType == siICEShapeReference)
         {
            // These shapes have their own matrix, so each point is replaced by a node with its own matrix.
            // The matrix must enclose the full srt transform, as the shapes are always created as unit primitives
            scale.ScaleInPlace(size);
            ori = iceAttributes.GetOrientation(pointIndex);
            orientationf = iceAttributes.GetOrientationf(pointIndex);
            if (nbTransfKeys > 1)
            {
               vel    = iceAttributes.GetPointVelocity(pointIndex);
               angVel = iceAttributes.GetAngularVelocity(pointIndex);
               if (doExactTransformMb)
               {
                  for (int iKey = 0; iKey < nbTransfKeys; iKey++)
                     mbScale[pointIndex * nbTransfKeys + iKey].ScaleInPlace(mbSize[pointIndex * nbTransfKeys + iKey]);
               }
            }
         }

         switch (shapeType)
         {
            // multi-point objects. They all derive from CIceObjectPoints
            case siICEShapeSphere:
               if (!isStrandInstance)
               {
                  // Set the point position. We use the 0-th key to store it.
                  // In case there is no mb, that's it. Else, the further mb position will be computed out of the 0-th
                  // position stored here (and the 0-th one will be overwritten correctly as well)
                  iceObjects.m_pointsSphere[0].SetPoint(pos, pointsSphereIndex, 0); 
                  // Note that we multiply size by scale.x. We cannot match the exact look of Soft, that can have
                  // spheres and points scaled along x,y,z. The Arnold point primitive has a unique matrix, and
                  // for each point we can set only a unique radius (not 3). So, let's us the scale x, to give
                  // at least the chance to use the scale on points objects
                  iceObjects.m_pointsSphere[0].SetRadius(size*scale.GetX(), pointsSphereIndex, 0);
                  if (nbTransfKeys > 1)
                  {
                     // The mb for the points node is achieved with the arrays of points and radii, so we must set them all here
                     // since to do this we need the point's velocity
                     vel = iceAttributes.GetPointVelocity(pointIndex);
                     iceObjects.m_pointsSphere[0].ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, doExactTransformMb, 
                                                                    mbPos, mbSize, pointsSphereIndex, pointIndex);
                  }
                  // write the pointIndex-th attribute into the pointsSphereIndex-th user data array
                  if (doAttributes)
                     iceObjects.m_pointsSphere[0].DeclareAttributes(&iceAttributes, in_frame, pointIndex, pointsSphereIndex, iceObjects.m_pointsSphereNbPoints);
                  pointsSphereIndex++;
               }
               break;

            case siICEShapePoint: // points are exported as flat disks. We do the same as before, except we use the pointsDisk[0] class
               if (!isStrandInstance)
               {
                  iceObjects.m_pointsDisk[0].SetPoint(pos, pointsDiskIndex, 0);
                  iceObjects.m_pointsDisk[0].SetRadius(size*scale.GetX(), pointsDiskIndex, 0);
                  if (nbTransfKeys > 1)
                  {
                     vel = iceAttributes.GetPointVelocity(pointIndex);
                     iceObjects.m_pointsDisk[0].ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, doExactTransformMb, mbPos, mbSize, pointsDiskIndex, pointIndex);
                  }
                  if (doAttributes)
                     iceObjects.m_pointsDisk[0].DeclareAttributes(&iceAttributes, in_frame, pointIndex, pointsDiskIndex, iceObjects.m_pointsDiskNbPoints);
                  pointsDiskIndex++;
               }
               break;

            case siICEShapeRectangle: // points are exported as flat disks. We do the same as before, except we use the pointsDisk[0] class
               if (!isStrandInstance)
               {
                  iceObjects.m_rectangles[0].SetPoint(pos, rectanglesIndex, 0);
                  CVector3f scaledScale = scale;
                  scaledScale.ScaleInPlace(size);
                  iceObjects.m_rectangles[0].SetScale(scaledScale, rectanglesIndex, 0);
                  ori = iceAttributes.GetOrientation(pointIndex);
                  iceObjects.m_rectangles[0].SetRotation(ori, rectanglesIndex, 0);
                  if (nbTransfKeys > 1)
                  {
                     vel = iceAttributes.GetPointVelocity(pointIndex);
                     iceObjects.m_rectangles[0].ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, doExactTransformMb, mbPos, mbScale, mbOri, rectanglesIndex, pointIndex);
                  }
                  if (doAttributes)
                     iceObjects.m_rectangles[0].DeclareAttributes(&iceAttributes, in_frame, pointIndex, rectanglesIndex, iceObjects.m_nbRectangles);
                  rectanglesIndex++;
               }
               break;

            // single-point objects. They all derive from CIceObjectBaseShape, and are unit primitives (their position == 0).
            // So, all their placing is defined only by their matrix
            case siICEShapeDisc:
               if (!isStrandInstance)
               {
                  // set the transform of the point out of this point pos, scale and orientation
                  iceObjects.m_discs[discIndex].SetTransf(pos, scale, ori);
                  if (nbTransfKeys > 1) // mb enabled? write the node matrix for this key, based on the point vels
                     iceObjects.m_discs[discIndex].ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, angVel, doExactTransformMb, mbPos, mbScale, mbOri, pointIndex);
                  else // give the node matrix equal to the above transformation
                     iceObjects.m_discs[discIndex].SetMatrix(iceObjects.m_discs[discIndex].m_transf, 0);
                  if (doAttributes) // export the attributes
                     iceObjects.m_discs[discIndex].DeclareAttributes(&iceAttributes, in_frame, pointIndex);
                  discIndex++;
               }
               break;

            // same as before, just different types of nodes
            case siICEShapeBox:
               if (!isStrandInstance)
               {
                  iceObjects.m_boxes[boxIndex].SetTransf(pos, scale, ori);
                  if (nbTransfKeys > 1)
                     iceObjects.m_boxes[boxIndex].ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, angVel, doExactTransformMb, mbPos, mbScale, mbOri, pointIndex);
                  else
                     iceObjects.m_boxes[boxIndex].SetMatrix(iceObjects.m_boxes[boxIndex].m_transf, 0);
                  if (doAttributes)
                     iceObjects.m_boxes[boxIndex].DeclareAttributes(&iceAttributes, in_frame, pointIndex);
                  boxIndex++;
               }
               break;

            case siICEShapeCylinder:
               if (!isStrandInstance)
               {
                  iceObjects.m_cylinders[cylinderIndex].SetTransf(pos, scale, ori);
                  if (nbTransfKeys > 1)
                     iceObjects.m_cylinders[cylinderIndex].ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, angVel, doExactTransformMb, mbPos, mbScale, mbOri, pointIndex);
                  else
                     iceObjects.m_cylinders[cylinderIndex].SetMatrix(iceObjects.m_cylinders[cylinderIndex].m_transf, 0);
                  if (doAttributes)
                     iceObjects.m_cylinders[cylinderIndex].DeclareAttributes(&iceAttributes, in_frame, pointIndex);
                  cylinderIndex++;
               }
               break;

            case siICEShapeCone:
               if (!isStrandInstance)
               {
                  iceObjects.m_cones[coneIndex].SetTransf(pos, scale, ori);
                  if (nbTransfKeys > 1)
                     iceObjects.m_cones[coneIndex].ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, angVel, doExactTransformMb, mbPos, mbScale, mbOri, pointIndex);
                  else
                     iceObjects.m_cones[coneIndex].SetMatrix(iceObjects.m_cones[coneIndex].m_transf, 0);
                  if (doAttributes)
                     iceObjects.m_cones[coneIndex].DeclareAttributes(&iceAttributes, in_frame, pointIndex);
                  coneIndex++;
               }
               break;

            // instances
            case siICEShapeInstance:
            case siICEShapeReference:
               if (!isStrandInstance)
               {
                  CIceObjectInstance *objInstance = &iceObjects.m_instances[instanceIndex];
                  // set the master id for this instance set, so the object or model to be instanced
                  objInstance->SetMasterId(shape.GetReferenceID());
                  // Set the transformation
                  objInstance->SetTransf(pos, scale, ori);

                  if (nbTransfKeys > 1) // mb enabled? write the matrices for this key, based on the point vel
                     objInstance->ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, angVel, doExactTransformMb, mbPos, mbScale, mbOri, pointIndex);
                  else // give the node a matrix equal to the above transformation
                     objInstance->SetMatrix(objInstance->m_transf, 0);

                  // add all the shapes (so, the ginstances) for this point
                  objInstance->AddShapes(keyTransformAtFrame, shapeFrame, iceAttributes.HasShapeTime(), shapeHierarchyMap, 
                                         in_selectedObjs, in_selectionOnly, &iceObjects, instanceIndex, out_postLoadedNodesToHide);
                  // now we have the members (ginstances), and we can push the attributes
                  if (doAttributes)
                     for (int i=0; i<(int)objInstance->m_members.size(); i++)
                        objInstance->m_members[i].DeclareAttributes(&iceAttributes, in_frame, pointIndex);

                  instanceIndex++;
               }
               else // initialize the strand for this strandInstance
               {
                  bool strandSizeOk = iceAttributes.GetStrandSize(pointIndex, strandSize);
                  bool strandVelOk = iceAttributes.GetStrandVelocity(pointIndex, strandVel);
                  bool strandOrientationOk = iceAttributes.GetStrandOrientation(pointIndex, strandOrientation);

                  int nbStrandPoints = (int)strandPos.GetCount();
                  int nbStrandVel = nbDefKeys > 1 ? nbStrandPoints : 0;
                  int nbStrandOrientation = (int)strandPos.GetCount();
                  // alloc the strand structure. This strand has nbStrandPoints points, nbStrandPoints radii, 
                  // nbStrandPoints orientations, and nbStrandVel velocities (that is 0 if mb is off)
                  iceObjects.m_strandInstances[strandInstanceIndex].m_strand.Init(nbStrandPoints, nbStrandPoints, nbStrandVel, nbStrandOrientation);
                  // init the mbStrand to be used for mb, if deform mb is on. Id does not need the vel
                  if (nbDefKeys > 1)
                     iceObjects.m_strandInstances[strandInstanceIndex].m_mbStrand.Init(nbStrandPoints, nbStrandPoints, 0, nbStrandOrientation);

                  CStrand *strand = &iceObjects.m_strandInstances[strandInstanceIndex].m_strand;

                  for (int i=0; i<nbStrandPoints; i++)
                  {
                     CVector3f strandP = strandPos[i];
                     // set the i-th strand's point position
                     strand->SetPoint(strandP, i);
                     if (strandSizeOk)
                     {
                        // set the radius equal to the strand size at i
                        index = strandSize.GetCount() > 1 ? i : 0;
                        float strandS = strandSize[index];
                        strand->SetRadius(strandS, i);
                     }
                     else // no strand size. Use the point's size, so the strand has uniform thickness
                        strand->SetRadius(size, i);

                     if (nbDefKeys > 1) // set strand points' velocity
                     {
                        if (strandVelOk)
                        {
                           // set the velocities equal to the strand sizes
                           index = strandVel.GetCount() > 1 ? i : 0;
                           CVector3f strandV = strandVel[index];
                           strand->SetVelocity(strandV, i);
                        }
                        else // no strand vel. Use the point's velocity, so the strand has uniform velocity
                           strand->SetVelocity(vel, i);
                     }

                     // set the i-th point orientation
                     if (strandOrientationOk)
                     {
                        // set the orientation equal to the strand size at i
                        index = strandOrientation.GetCount() > 1 ? i : 0;
                        CRotationf strandR = strandOrientation[index];
                        strand->SetOrientation(strandR, i);
                     }
                     else
                        strand->SetOrientation(orientationf, i);
                  }
                  // extra mandatory stuff to load well the strand
                  strand->ComputeLength();
                  // compute a set of points, running side by side the strand
                  // that are used to "lock" the local x axis as the strand bends/twirls
                  strand->ComputeBendedX(false, 0.0f);
                  // strand->Log();

                  CIceObjectStrandInstance *strandInstance = &iceObjects.m_strandInstances[strandInstanceIndex];
                  // set the master id for this instance set, so the object or model to be instanced
                  strandInstance->SetMasterId(shape.GetReferenceID());
                  // Set the transformation
                  strandInstance->SetTransf(pos, scale, ori);
                  if (nbTransfKeys > 1) // transf mb enabled? write the matrices for this key, based on the point vel
                     strandInstance->ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, angVel, doExactTransformMb, mbPos, mbScale, mbOri, pointIndex);
                  else // give the node matrix equal to the above transformation
                     strandInstance->SetMatrix(strandInstance->m_transf, 0);

                  // clone the shapes on this strand
                  strandInstance->AddStrandShapes(keyDeformAtTimeZero, shapeFrame, &iceObjects, strandInstanceIndex, secondsPerFrame);
                  // now we have the members (cloned polymeshes), and we can push the attributes
                  // that will be of constant or uniform (one per polymesh) type
                  if (doAttributes)
                     for (int i=0; i<(int)strandInstance->m_members.size(); i++)
                        strandInstance->m_members[i].DeclareAttributes(&iceAttributes, in_frame, pointIndex);

                  strandInstanceIndex++;
               }

               break;

            default:
               break;
         }
      } // end of the current chunk
   } // end of the chunks loop

   // do the light association only once (#1721) if the pointcloud originated clones of lights
   if (iceObjects.HasAtLeastOneInstancedLight())
      DoFullLightAssociation(in_frame);

   // clear the exact mb stuff asap
   if (doExactTransformMb)
   {
      mbPos.clear();
      mbScale.clear();
      mbSize.clear();
      mbOri.clear();
   }
   if (doExactDeformMb)
      mbStrandPos.clear();

   // build all the quad arrays out of the collected data
   if (iceObjects.m_rectangles.size() > 0)
      iceObjects.m_rectangles[0].MakeQuad(doExactDeformMb);

   // Strand nodes are still to be built, until here he just stores their data
   if (iceObjects.m_strands.size() > 0)
   {
      // build all the curves arrays from the CStrand object
      iceObjects.m_strands[0].MakeCurve(arnoldParameters, shapeFrame, keyDeformAtTimeZero, secondsPerFrame, doExactDeformMb);
      // last loop to give the strands the attributes
      if (doAttributes)
      {
         strandIndex = 0;
         int offset=0;
         for (LONG pointOffset=0; pointOffset < pointCount; pointOffset+=ICE_CHUNK_SIZE)
         {
            LONG nbPoints = pointCount - pointOffset < ICE_CHUNK_SIZE ? pointCount - pointOffset : ICE_CHUNK_SIZE;
            iceAttributes.UpdateChunk(pointOffset, nbPoints); //update all

            for (LONG pointIndex = 0; pointIndex < nbPoints; pointIndex++)
            {
               if (iceAttributes.GetSize(pointIndex, 1.0f) < 0.0001f) // #1562
                  continue;

               // Checking if this is this a strand. This could be avoided, storing a "is-this-a-strand" map
               // just once in one of the previous points loops
               if (iceAttributes.GetStrandPosition(pointIndex, strandPos) && (strandPos.GetCount() > 1)) 
               {
                  iceObjects.m_strands[0].DeclareAttributes(&iceAttributes, in_frame, pointIndex, strandIndex, offset);
                  // the index for the array to be written. So, increment it by the strand's number of points
                  offset+= (int)iceObjects.m_strands[0].m_strands[strandIndex].m_points.size();
                  strandIndex++;
               }
            }
         }
      }
   }

   // set the matrices for the multi-point node
   for (int iKey=0; iKey<nbTransfKeys; iKey++)
   {
      CTransformation transform = in_xsiObj.GetKinematics().GetGlobal().GetTransform(keyTransformAtFrame[iKey]);
      // CVector3 s = transform.GetScaling();
      // GetMessageQueue()->LogMessage(L"Scale = " + (CString)s.GetX() + L" " + (CString)s.GetY() + L" " + (CString)s.GetZ());
      if (iceObjects.m_pointsSphere.size() > 0)
         iceObjects.m_pointsSphere[0].SetMatrix(transform, iKey);
      if (iceObjects.m_pointsDisk.size() > 0)
        iceObjects.m_pointsDisk[0].SetMatrix(transform, iKey);
      if (iceObjects.m_rectangles.size() > 0)
        iceObjects.m_rectangles[0].SetMatrix(transform, iKey);
      if (iceObjects.m_strands.size() > 0)
        iceObjects.m_strands[0].SetMatrix(transform, iKey);
   }

   // Finally, we still have to multiply all the matrices of the non-multipoint objects
   // by the pointcloud matrices.
   // Create a matrix array to store the transforms of the pointcloud
   AtMatrix matrix;
   AtArray* pointCloudMatrices = AiArrayAllocate(1, (uint8_t)nbTransfKeys, AI_TYPE_MATRIX);
   for (int iKey=0; iKey<nbTransfKeys; iKey++)
   {
      CUtilities().S2A(in_xsiObj.GetKinematics().GetGlobal().GetTransform(keyTransformAtFrame[iKey]), matrix);
      AiArraySetMtx(pointCloudMatrices, iKey, matrix);
   }
   // Go transform
   iceObjects.MultiplyInstancesByPointCloudMatrices(pointCloudMatrices);

   // Set the viz and sidedness for all the nodes generated for this pointcloud
   // if (arnoldVisibilityOnPointCloud)
   iceObjects.SetNodesVisibility(pointCloudVisibility, arnoldVisibilityOnPointCloud);
   if (arnoldSidednessOnPointCloud)
      iceObjects.SetNodesSidedness(pointCloudSidedness);
   // Give all the nodes (except the instances) the shaders
   iceObjects.SetNodesShader(shaderNode);

   // Connect the nodes attributes with the classes attributes
   iceObjects.SetNodesData();
   // export all the property stuff
   iceObjects.SetArnoldParameters(arnoldParameters, in_frame);
   iceObjects.SetMotionStartEnd();
   iceObjects.SetArnoldUserOptions(userOptionsProperty, in_frame);
   iceObjects.SetUserDataBlobs(in_xsiObj, in_frame);
   iceObjects.SetMatte(matteProperty, in_frame);

   // Lights association (#1210) 
   AtArray* lightGroup = GetRenderInstance()->LightMap().GetLightGroup(in_xsiObj);
   if (lightGroup)
      iceObjects.SetLightGroup(lightGroup);

   vector <AtNode*> members = iceObjects.GetAllNodes();
   if (members.size() > 0)
   {
      GetRenderInstance()->GroupMap().PushGroup(&members, in_xsiObj, in_frame);
      members.clear();
   }

   return CStatus::OK;
}


// Load a pointcloud object as a points node, regardless of the points shape, for volume rendering in "points" mode
// This function was simply copied LoadSinglePointCloud, "downgraded" to points, and getting the shader from the volume port
//
// @param in_xsiObj              The Softimage pc
// @param in_frame               The frame
//
// @return CStatus:OK if all went well, else the error CStatus
//
CStatus LoadVolumePointCloud(const X3DObject &in_xsiObj, double in_frame)
{
   CString xsiObjName = in_xsiObj.GetFullName();
   CRefArray iceProperties = in_xsiObj.GetProperties();

   float frameRate = (float)CTimeUtilities().GetFps();
   float secondsPerFrame = frameRate > 1.0 ? 1.0f / frameRate : 1.0f;

   Geometry xsiGeo = CObjectUtilities().GetGeometryAtFrame(in_xsiObj, in_frame);

   // initialize the main attributes set
   CIceAttributesSet iceAttributes(in_xsiObj, xsiGeo);
   // collect all the required attributes, the second arg is void since it's used only for polymeshes
   iceAttributes.CollectRequiredAttributes(in_frame, CRefArray(), false, false);

   CDoubleArray keyTransformAtTimeZero, keyDeformAtTimeZero, keyTransformAtFrame, keyDeformAtFrame;
   // get the mb times at time 0 (#809)
   CSceneUtilities::GetMotionBlurData(in_xsiObj.GetRef(), keyTransformAtTimeZero, keyDeformAtTimeZero, 0, true);
   // Get the actual time for the mb steps, not centered at 0 as above.
   CSceneUtilities::GetMotionBlurData(in_xsiObj.GetRef(), keyTransformAtFrame, keyDeformAtFrame, in_frame, true);
   LONG nbTransfKeys = keyTransformAtTimeZero.GetCount();

   CustomProperty arnoldParameters, userOptionsProperty;
   iceProperties.Find(L"arnold_parameters", arnoldParameters);
   iceProperties.Find(L"arnold_user_options", userOptionsProperty);
   
   Material material(in_xsiObj.GetMaterial());
   AtNode* shaderNode = LoadMaterial(material, LOAD_MATERIAL_SURFACE, in_frame, in_xsiObj.GetRef());

   Property prop;
   iceProperties.Find(L"arnold_visibility", prop);
   bool arnoldVisibilityOnPointCloud = prop.IsValid();

   uint8_t pointCloudVisibility = GetVisibility(iceProperties, in_frame);

   uint8_t pointCloudSidedness;
   bool arnoldSidednessOnPointCloud = GetSidedness(iceProperties, in_frame, pointCloudSidedness);

   // check the pointPosition attribute, if is invalid or empty skip this cloud
   ICEAttribute pointPositionAttribute = xsiGeo.GetICEAttributeFromName(L"PointPosition");
   LONG pointCount = pointPositionAttribute.GetElementCount();
   
   if (!pointPositionAttribute.IsDefined() || !pointPositionAttribute.IsValid() || pointCount == 0)
      return CStatus::OK;

   iceAttributes.GetRequiredAttributesSet();
   iceAttributes.GetProvidedAttributesSet();
   iceAttributes.BuildAttributesMaps(true, true);
   bool doAttributes = iceAttributes.m_requiredAttributesMap.size() > 0;
   iceAttributes.ConnectAttributeHandlers();

   CIceObjects iceObjects;
   
   for (LONG pointOffset=0; pointOffset < pointCount; pointOffset+=ICE_CHUNK_SIZE)
   {
      LONG nbPoints = pointCount - pointOffset < ICE_CHUNK_SIZE ? pointCount - pointOffset : ICE_CHUNK_SIZE;
      iceAttributes.UpdateChunk(pointOffset, nbPoints); //update all the main attributes

      for (LONG pointIndex = 0; pointIndex < nbPoints; pointIndex++)
      {
         if (iceAttributes.GetSize(pointIndex, 1.0f) < 0.0001f) 
            continue;
         iceObjects.m_pointsSphereNbPoints++;
      }
   }

   if (iceObjects.m_pointsSphereNbPoints > 0)
   {
      // we have at least a sphere object, that is exported as a points node with mode = sphere
      iceObjects.m_pointsSphere.resize(1); // alloc the object. resize(1) may look weird, but I prefer to be consistent with the rest
      CString name = CStringUtilities().MakeSItoAName((SIObject)in_xsiObj, in_frame, L"Sphere", false);
      iceObjects.m_pointsSphere[0].CreateNode(CObjectUtilities().GetId(in_xsiObj), name.GetAsciiString(), nbTransfKeys);
      iceObjects.m_pointsSphere[0].Resize(iceObjects.m_pointsSphereNbPoints, nbTransfKeys);
   }

   int pointsSphereIndex(0);

   CVector3f  pos, vel, scale;
   CRotation  ori, angVel;
   float      size;
   double     shapeFrame(in_frame);
   vector <CVector3f> mbPos, mbScale;
   vector <float>     mbSize;

   // loop to fill the iceAttributes class with all the needed data
   for (LONG pointOffset=0; pointOffset < pointCount; pointOffset+=ICE_CHUNK_SIZE)
   {
      LONG nbPoints = pointCount - pointOffset < ICE_CHUNK_SIZE ? pointCount - pointOffset : ICE_CHUNK_SIZE;
      iceAttributes.UpdateChunk(pointOffset, nbPoints);

      for (LONG pointIndex = 0; pointIndex < nbPoints; pointIndex++)
      {
         size = iceAttributes.GetSize(pointIndex, 1.0f);
         if (size < 0.0001f) 
            continue;

         pos = iceAttributes.GetPointPosition(pointIndex);
         if (nbTransfKeys > 1)
            vel = iceAttributes.GetPointVelocity(pointIndex);

         shapeFrame = in_frame;

         scale = iceAttributes.GetScale(pointIndex);

         iceObjects.m_pointsSphere[0].SetPoint(pos, pointsSphereIndex, 0); 
         // Note that we multiply size by scale.x. We cannot match the exact look of Soft, that can have
         // spheres and points scaled along x,y,z. The Arnold point primitive has a unique matrix, and
         // for each point we can set only a unique radius (not 3). So, let's us the scale x, to give
         // at least the chance to use the scale on points objects
         iceObjects.m_pointsSphere[0].SetRadius(size*scale.GetX(), pointsSphereIndex, 0);
         if (nbTransfKeys > 1)
         {
            // The mb for the points node is achieved with the arrays of points and radii, so we must set them all here
            // since to do this we need the point's velocity
            vel = iceAttributes.GetPointVelocity(pointIndex);
            iceObjects.m_pointsSphere[0].ComputeMotionBlur(keyTransformAtTimeZero, secondsPerFrame, vel, false, 
                                                           mbPos, mbSize, pointsSphereIndex, pointIndex);
         }
         // write the pointIndex-th attribute into the pointsSphereIndex-th user data array
         if (doAttributes)
            iceObjects.m_pointsSphere[0].DeclareAttributes(&iceAttributes, in_frame, pointIndex, pointsSphereIndex, iceObjects.m_pointsSphereNbPoints);
         pointsSphereIndex++;
      } // end of the current chunk
   }

   for (int iKey=0; iKey<nbTransfKeys; iKey++)
   {
      CTransformation transform = in_xsiObj.GetKinematics().GetGlobal().GetTransform(keyTransformAtFrame[iKey]);
      if (iceObjects.m_pointsSphere.size() > 0)
         iceObjects.m_pointsSphere[0].SetMatrix(transform, iKey);
   }

   // Set the viz and sidedness for all the nodes generated for this pointcloud
   iceObjects.SetNodesVisibility(pointCloudVisibility, arnoldVisibilityOnPointCloud);
   if (arnoldSidednessOnPointCloud)
      iceObjects.SetNodesSidedness(pointCloudSidedness);
   // Give all the nodes (except the instances) the shaders
   iceObjects.SetNodesShader(shaderNode);

   // Connect the nodes attributes with the classes attributes
   iceObjects.SetNodesData();
   // export all the property stuff
   iceObjects.SetArnoldParameters(arnoldParameters, in_frame);
   iceObjects.SetMotionStartEnd();
   iceObjects.SetArnoldUserOptions(userOptionsProperty, in_frame);
   iceObjects.SetUserDataBlobs(in_xsiObj, in_frame);

   // Lights association (#1210) 
   AtArray* lightGroup = GetRenderInstance()->LightMap().GetLightGroup(in_xsiObj);
   if (lightGroup)
      iceObjects.SetLightGroup(lightGroup);

   vector <AtNode*> members = iceObjects.GetAllNodes();
   if (members.size() > 0)
   {
      GetRenderInstance()->GroupMap().PushGroup(&members, in_xsiObj, in_frame);
      members.clear();
   }

   return CStatus::OK;
}


