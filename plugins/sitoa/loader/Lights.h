/************************************************************************************************************************************
Copyright 2017 Autodesk, Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. 
You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, 
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
See the License for the specific language governing permissions and limitations under the License.
************************************************************************************************************************************/

#pragma once

#include "renderer/AtNodeLookup.h"

#include <xsi_light.h>

#include <ai_nodes.h>

#define MAX_FILTERS 5


class CLight
{
private:
   // the arnold light nodes: 
   // m_nodes[0] == the master
   // m_nodes[>0] == the master instances, generated by DuplicateLightNode
   vector <AtNode*> m_nodes;
   set <CString>    m_associatedObjects; // the associated objects for light linking

public:
   Light   m_xsiLight;     // the softimage light
   bool    m_hasMembers;   // does this light has objects in the associated models group?
   bool    m_isInclusive;  // if so, inclusive/exclusive flag

   CLight()
   {
      m_hasMembers = m_isInclusive = false;
   }

   ~CLight() 
   {
      m_nodes.clear();
      m_associatedObjects.clear();
   }

   CLight(const CLight& in_arg) :
      m_hasMembers(in_arg.m_hasMembers), m_isInclusive(in_arg.m_isInclusive)
   {
      m_nodes             = in_arg.m_nodes;
      m_xsiLight          = in_arg.m_xsiLight;
      m_associatedObjects = in_arg.m_associatedObjects;
   }

   // Construct by inputs
   CLight(AtNode *in_light, Light in_xsiLight)
   {
      m_nodes.push_back(in_light);
      m_xsiLight = in_xsiLight;
   }

   // = overload
   const CLight& operator=(const CLight& in_arg);

   // Push an arnold node
   void PushNode(AtNode *in_node)
   {
      m_nodes.push_back(in_node);
   }

   // Get the Arnold master light node
   AtNode* GetMasterNode()
   {
      if (m_nodes.size() == 0)
         return NULL;
      return m_nodes[0];
   }

   // Get all the nodes
   vector <AtNode*>* GetAllNodes()
   {
      if (m_nodes.size() == 0)
         return NULL;
      return &m_nodes;
   }
   // Erase a light node from the nodes belonging to this light
   void EraseNode(AtNode *in_node);
   // Get the associated models group, and set m_hasMembers and m_isInclusive accordingly
   bool GetAssociatedModelsGroupSettings();
   // Add an object to the association set
   void AddAssociatedObject(X3DObject in_xsiObject);
   // Do the full objects association for this light
   void DoAssociation(void);
   // Find an object in the association set
   bool FindAssociatedObject(X3DObject in_xsiObject);
   // Erase an object from the association set
   void EraseAssociatedObject(CString &in_objectName);
   // Get the associate objects set pointer
   set <CString> *GetAssociatedObjects();
   // Clear the association set
   void ClearAssociatedObjects();
   // Update the light, when in flythrough mode
   void FlythroughUpdate();
   // debug
   void Log();
};


class CLightMap
{
private:
   map <AtNodeLookupKey, CLight> m_map;
public:
   // Default constructor
   CLightMap() {}

   // Default destructor
   ~CLightMap()
   {
      m_map.clear();
   }

   // Push into map by CLight and key
   void Push(CLight in_group, AtNodeLookupKey in_key);
   // Push into map by arnold node, xsi light and key
   void Push(AtNode *in_light, Light in_xsiLight, AtNodeLookupKey in_key);
   // Push into map by arnold node, xsi light and frame
   void Push(AtNode *in_light, Light in_xsiLight, double in_frame);

   // Find the light in the map
   CLight* Find(CString &in_name, double in_frame);
   // Find the light in the map
   CLight* Find(const Light &in_xsiLight, double in_frame);
   // Erase the light in the map
   void Erase(CString &in_name, double in_frame);
   // Loop all the lights and return true if at least one exploits association
   bool AtLeastOneLightHasMembers();
   // Get an array of lights node pointers that affects the object
   AtArray* GetLightGroup(const X3DObject &in_xsiObj);
   // Cycle all the lights and erase a light node from the nodes belonging to the lights
   void EraseNode(AtNode *in_node);
   // Erase an object from the association set of all the lights
   void EraseAssociatedObject(CString &in_objectName);
   // Update all the lights, when in flythrough mode
   void FlythroughUpdate();
   // clear the map;
   void Clear();
   // debug
   void Log();
};


// Search all XSI lights to load into Arnold
CStatus LoadLights(double in_frame, CRefArray &in_selectedObjs, bool in_selectionOnly = false);
// Load Light of type "Point" into Arnold
CStatus LoadSingleLight(const Light &in_xsiLight, double in_frame, bool in_postLoad=false);
// Check if a light filter is compatible with a light type
bool IsFilterCompatibleWithLight(CString in_lightType, CString in_filterType);
// Collect all the valid shaders connected to a Softimage light shader
CRefArray CollectFilterShaders(AtNode *in_lightNode, const Light &in_xsiLight, const Shader &in_lightShader);
// Load all the light filters connected to a Softimage lightvshader
CStatus LoadLightFilters(AtNode *in_light, const Light &in_xsiLight, const Shader &in_lightShader, double in_frame);
// Duplicate a light node
AtNode* DuplicateLightNode(const Light& in_xsiLight, CString in_nodeName, double in_frame);
// Do the full shape/lights association
void DoFullLightAssociation(double in_frame);

bool GetArnoldLightNodeName(const CString &in_lightShaderName, CString &out_arnoldNodeName);

